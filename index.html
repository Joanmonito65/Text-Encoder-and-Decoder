<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Text Encoder/Decoder</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');

body {
    margin: 0;
    padding: 0;
    font-family: 'Inter', sans-serif;
    background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    color: #fff;
}

.container {
    background-color: rgba(0,0,0,0.75);
    padding: 40px;
    border-radius: 20px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    max-width: 600px;
    width: 90%;
    text-align: center;
}

h1 {
    margin-bottom: 20px;
    font-weight: 600;
}

.tabs {
    display: flex;
    flex-wrap: nowrap;
    overflow-x: auto;
    gap: 5px;
    justify-content: flex-start;
    margin-bottom: 15px;
    scrollbar-width: none;
}

.tabs::-webkit-scrollbar {
    display: none;
}

.tab {
    padding: 8px 12px;
    border-radius: 10px 10px 0 0;
    background-color: #6c4dff;
    cursor: pointer;
    white-space: nowrap;
    flex-shrink: 0;
    transition: 0.3s;
}

.tab.active {
    background-color: #570ed4;
}

textarea {
    width: 100%;
    height: 120px;
    padding: 15px;
    border-radius: 10px;
    border: none;
    font-size: 16px;
    resize: none;
    margin-bottom: 20px;
}

#dropArea {
    margin-bottom: 15px;
    padding: 15px;
    border: 2px dashed rgba(255,255,255,0.5);
    border-radius: 10px;
    cursor: pointer;
}

#dropArea.dragover {
    background-color: rgba(255,255,255,0.1);
}

#resultContainer {
    margin-top: 20px;
    background-color: rgba(255,255,255,0.1);
    padding: 15px;
    border-radius: 10px;
    min-height: 50px;
    max-height: 200px;
    font-size: 15px;
    display: block;
    text-align: left;
    overflow-y: auto;
    word-break: break-all;
}

#resultContainer::-webkit-scrollbar {
    width: 8px;
}

#resultContainer::-webkit-scrollbar-track {
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
}

#resultContainer::-webkit-scrollbar-thumb {
    background: rgba(255,255,255,0.3);
    border-radius: 10px;
}

.button, .copy-btn, .reverse-btn {
    color: #fff;
    border: none;
    padding: 12px 25px;
    margin: 5px;
    font-size: 16px;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.button, .copy-btn {
    background-color: #6c4dff;
}

.button:hover, .copy-btn:hover {
    background-color: #570ed4;
    transform: translateY(-1px);
}

.reverse-btn {
    background-color: #ff9800;
}

.reverse-btn:hover {
    background-color: #f96540;
    transform: translateY(-1px);
}

@keyframes pop {
    0% { transform: scale(1); }
    50% { transform: scale(1.18); }
    100% { transform: scale(1); }
}

.button.copied, .copy-btn.copied {
    animation: pop 0.28s ease;
}
</style>
</head>
<body>

<div class="container">
    <h1>Text Encoder/Decoder</h1>

    <div class="tabs">
        <div class="tab active" data-type="base64">Base64</div>
        <div class="tab" data-type="hex">Hex</div>
        <div class="tab" data-type="url">URL</div>
        <div class="tab" data-type="html">HTML</div>
        <div class="tab" data-type="unicode">Unicode</div>
        <div class="tab" data-type="ascii">ASCII</div>
        <div class="tab" data-type="morse">Morse</div>
        <div class="tab" data-type="binary">Binary</div>
        <div class="tab" data-type="octal">Octal</div>
        <div class="tab" data-type="base32">Base32</div>
        <div class="tab" data-type="base58">Base58</div>
        <div class="tab" data-type="base64url">Base64Url</div>
        <div class="tab" data-type="ascii85">Ascii85</div>
        <div class="tab" data-type="z85">Z85</div>
        <div class="tab" data-type="base36">Base36</div>
        <div class="tab" data-type="base62">Base62</div>
        <div class="tab" data-type="base58check">Base58Check</div>
        <div class="tab" data-type="binhex">BinHex</div>
        <div class="tab" data-type="rot13">ROT13</div>
        <div class="tab" data-type="urlbase64">URL-Safe Base64</div>
        <div class="tab" data-type="utf8">UTF-8 Bytes</div>
        <div class="tab" data-type="binary16">Binary16</div>
        <div class="tab" data-type="rot47">ROT47</div>
        <div class="tab" data-type="atbash">Atbash</div>
        <div class="tab" data-type="caesar">Caesar</div>
        <div class="tab" data-type="vigenere">Vigenère</div>
        <div class="tab" data-type="reverse">Reverse</div>
        <div class="tab" data-type="uuencode">UUencode</div>
        <div class="tab" data-type="xxencode">XXencode</div>
        <div class="tab" data-type="rot5">ROT5</div>
        <div class="tab" data-type="rot18">ROT18</div>
        <div class="tab" data-type="substitution">Substitution</div>
        <div class="tab" data-type="baconian">Baconian</div>
        <div class="tab" data-type="railfence">Rail Fence</div>
        <div class="tab" data-type="polybius">Polybius</div>

    </div>

    <textarea id="inputText" placeholder="Enter text here..."></textarea>

    <div id="dropArea">Drag & Drop a text file here or click to select</div>
    <input type="file" id="fileInput" style="display:none;">

    <button class="button" onclick="encodeText()">Encode</button>
    <button class="button" onclick="decodeText()">Decode</button>
    <button class="reverse-btn" onclick="reverseText()">Reverse</button>

    <div id="resultContainer">
        <div id="result"></div>
    </div>

    <button class="copy-btn" onclick="copyResult(this)">Copy</button>
</div>

<script>
const inputText = document.getElementById("inputText");
const resultDiv = document.getElementById("result");
const dropArea = document.getElementById("dropArea");
const fileInput = document.getElementById("fileInput");
let lastAction = null;
let currentType = "base64";

document.querySelectorAll(".tab").forEach(tab => {
    tab.addEventListener("click", () => {
        document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
        tab.classList.add("active");
        currentType = tab.dataset.type;
        resultDiv.innerText = "";
    });
});

dropArea.addEventListener("dragover", (e) => {
    e.preventDefault();
    dropArea.classList.add("dragover");
});

dropArea.addEventListener("dragleave", () => {
    dropArea.classList.remove("dragover");
});

dropArea.addEventListener("drop", (e) => {
    e.preventDefault();
    dropArea.classList.remove("dragover");
    if(e.dataTransfer.files[0]) readFile(e.dataTransfer.files[0]);
});

dropArea.addEventListener("click", () => fileInput.click());
fileInput.addEventListener("change", () => {
    if(fileInput.files[0]) readFile(fileInput.files[0]);
});

function readFile(file) {
    if(!file.type.startsWith("text/")) {
        resultDiv.innerText = "Error: Only text files are allowed";
        return;
    }
    const reader = new FileReader();
    reader.onload = () => {
        inputText.value = reader.result;
        fileInput.value = "";
    };
    reader.readAsText(file);
}

const morseMap = {
    'A':'.-','B':'-...','C':'-.-.','D':'-..','E':'.','F':'..-.','G':'--.',
    'H':'....','I':'..','J':'.---','K':'-.-','L':'.-..','M':'--','N':'-.',
    'O':'---','P':'.--.','Q':'--.-','R':'.-.','S':'...','T':'-','U':'..-',
    'V':'...-','W':'.--','X':'-..-','Y':'-.--','Z':'--..',
    '0':'-----','1':'.----','2':'..---','3':'...--','4':'....-','5':'.....',
    '6':'-....','7':'--...','8':'---..','9':'----.',' ':'/','!':'-.-.--',
    '?':'..--..', '.':'.-.-.-', ',':'--..--', ':':'---...'
};

const base32chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";

function encodeBase32(str) {
    const bytes = new TextEncoder().encode(str);
    let bits = "";
    for (let b of bytes) bits += b.toString(2).padStart(8,"0");
    let output = "";
    for (let i = 0; i < bits.length; i += 5) {
        const chunk = bits.substring(i, i+5);
        output += base32chars[parseInt(chunk.padEnd(5,"0"),2)];
    }
    while (output.length % 8 !== 0) output += "=";
    return output;
}

function decodeBase32(str) {
    str = str.replace(/=/g,"");
    let bits = "";
    for (let c of str) bits += base32chars.indexOf(c).toString(2).padStart(5,"0");
    let bytes = [];
    for (let i = 0; i < bits.length; i += 8) {
        const byte = bits.substring(i, i+8);
        if (byte.length === 8) bytes.push(parseInt(byte,2));
    }
    return new TextDecoder().decode(new Uint8Array(bytes));
}

function rot47(str) {
    return str.replace(/[\x21-\x7E]/g, c =>
        String.fromCharCode(33 + ((c.charCodeAt(0) + 14) % 94))
    );
}

function atbash(str) {
    const a = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const z = 'ZYXWVUTSRQPONMLKJIHGFEDCBA';
    return str.replace(/[A-Za-z]/g, c => {
        const isLower = c >= 'a' && c <= 'z';
        const idx = a.indexOf(c.toUpperCase());
        const newChar = z[idx];
        return isLower ? newChar.toLowerCase() : newChar;
    });
}

function caesar(str, shift = 3) {
    return str.replace(/[A-Za-z]/g, c => {
        const base = c <= 'Z' ? 65 : 97;
        return String.fromCharCode(
            ((c.charCodeAt(0) - base + shift) % 26) + base
        );
    });
}

function vigenereEncrypt(text, key = "KEY") {
    key = key.toUpperCase().replace(/[^A-Z]/g,"");
    if (!key.length) return text;

    let out = "";
    let keyIndex = 0;

    for (let char of text) {
        const code = char.charCodeAt(0);

        if (char >= "A" && char <= "Z") {
            out += String.fromCharCode(
                ((code - 65 + (key[keyIndex % key.length].charCodeAt(0) - 65)) % 26) + 65
            );
            keyIndex++;
        }
        else if (char >= "a" && char <= "z") {
            out += String.fromCharCode(
                ((code - 97 + (key[keyIndex % key.length].charCodeAt(0) - 65)) % 26) + 97
            );
            keyIndex++;
        }
        else out += char;
    }
    return out;
}

function vigenereDecrypt(text, key = "KEY") {
    key = key.toUpperCase().replace(/[^A-Z]/g,"");
    if (!key.length) return text;

    let out = "";
    let keyIndex = 0;

    for (let char of text) {
        const code = char.charCodeAt(0);

        if (char >= "A" && char <= "Z") {
            out += String.fromCharCode(
                ((code - 65 - (key[keyIndex % key.length].charCodeAt(0) - 65) + 26) % 26) + 65
            );
            keyIndex++;
        }
        else if (char >= "a" && char <= "z") {
            out += String.fromCharCode(
                ((code - 97 - (key[keyIndex % key.length].charCodeAt(0) - 65) + 26) % 26) + 97
            );
            keyIndex++;
        }
        else out += char;
    }
    return out;
}

function reverse(str) {
    return str.split("").reverse().join("");
}

const base58charsCheck = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

function encodeBase58Check(str) {
    const crypto = window.crypto || window.msCrypto;
    let bytes = Array.from(new TextEncoder().encode(str));
    const hashBuffer = crypto.subtle.digest ? crypto.subtle.digest("SHA-256", new Uint8Array(bytes)) : null;
    if (!hashBuffer) return encodeBase58(str);
    return hashBuffer.then(hash => {
        const hashBytes = new Uint8Array(hash);
        const checksum = hashBytes.slice(0, 4);
        bytes = bytes.concat(Array.from(checksum));
        let num = BigInt("0x" + bytes.map(b => b.toString(16).padStart(2, "0")).join(""));
        let output = "";
        while (num > 0n) {
            const mod = num % 58n;
            num = num / 58n;
            output = base58charsCheck[Number(mod)] + output;
        }
        return output;
    });
}

function decodeBase58Check(str) {
    let num = 0n;
    for (let c of str) num = num * 58n + BigInt(base58charsCheck.indexOf(c));
    let hex = num.toString(16);
    if (hex.length % 2) hex = "0" + hex;
    let bytes = new Uint8Array(hex.match(/.{2}/g).map(h => parseInt(h,16)));
    bytes = bytes.slice(0, -4);
    return new TextDecoder().decode(bytes);
}

const base58chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

function encodeBase58(str) {
    let bytes = Array.from(new TextEncoder().encode(str));
    let num = BigInt("0x" + bytes.map(b => b.toString(16).padStart(2,"0")).join(""));
    let output = "";
    while (num > 0n) {
        const mod = num % 58n;
        num = num / 58n;
        output = base58chars[Number(mod)] + output;
    }
    return output;
}

function decodeBase58(str) {
    let num = 0n;
    for (let c of str) num = num * 58n + BigInt(base58chars.indexOf(c));
    let hex = num.toString(16);
    if (hex.length % 2) hex = "0" + hex;
    let bytes = new Uint8Array(hex.match(/.{2}/g).map(h => parseInt(h,16)));
    return new TextDecoder().decode(bytes);
}

function encodeAscii85(input) {
    let data = new TextEncoder().encode(input);
    let output = "<~";
    for (let i = 0; i < data.length; i += 4) {
        let chunk = data.slice(i, i+4);
        while (chunk.length < 4) chunk = new Uint8Array([...chunk, 0]);
        let num = (chunk[0]<<24) + (chunk[1]<<16) + (chunk[2]<<8) + chunk[3];

        if (num === 0) {
            output += "z";
        } else {
            let block = "";
            for (let j = 0; j < 5; j++) {
                block = String.fromCharCode((num % 85) + 33) + block;
                num = Math.floor(num / 85);
            }
            output += block;
        }
    }
    return output + "~>";
}

function uuencode(str) {
    return btoa(str).replace(/\+/g, "`").replace(/\//g, "~");
}

function uudecode(str) {
    return atob(str.replace(/`/g, "+").replace(/~/g, "/"));
}

function xxencode(str) {
    return btoa(str).replace(/\+/g, "x").replace(/\//g, "z");
}

function xxdecode(str) {
    return atob(str.replace(/x/g, "+").replace(/z/g, "/"));
}

function rot5(str) {
    return str.replace(/[0-9]/g, c =>
        String.fromCharCode(((c.charCodeAt(0) - 48 + 5) % 10) + 48)
    );
}

function rot18(str) {
    return rot13(rot5(str));
}

function substitution(str) {
    const a = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const b = "MNOPQRSTUVWXYZABCDEFGHIJKL";
    return str.replace(/[A-Za-z]/g, c => {
        const isLower = c >= "a" && c <= "z";
        const idx = a.indexOf(c.toUpperCase());
        const ch = b[idx];
        return isLower ? ch.toLowerCase() : ch;
    });
}

function baconianEncode(str) {
    const a = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let out = "";
    for (let c of str.toUpperCase()) {
        const i = a.indexOf(c);
        if (i === -1) out += c;
        else out += i.toString(2).padStart(5, "0").replace(/0/g, "A").replace(/1/g, "B");
    }
    return out;
}

function baconianDecode(str) {
    let out = "";
    str = str.replace(/[^AB]/g, "");
    for (let i = 0; i < str.length; i += 5) {
        const chunk = str.slice(i, i+5);
        if (chunk.length < 5) break;
        const val = parseInt(chunk.replace(/A/g,"0").replace(/B/g,"1"), 2);
        out += String.fromCharCode(65 + val);
    }
    return out;
}

function railFenceEncrypt(str, rails = 3) {
    const a = Array.from({length: rails}, () => []);
    let rail = 0, dir = 1;
    for (let c of str) {
        a[rail].push(c);
        rail += dir;
        if (rail === 0 || rail === rails - 1) dir *= -1;
    }
    return a.flat().join("");
}

function railFenceDecrypt(str, rails = 3) {
    const pattern = [];
    let rail = 0, dir = 1;
    for (let i = 0; i < str.length; i++) {
        pattern.push(rail);
        rail += dir;
        if (rail === 0 || rail === rails - 1) dir *= -1;
    }
    const railCounts = Array(rails).fill(0);
    pattern.forEach(r => railCounts[r]++);
    const railsArr = [];
    let pos = 0;
    for (let r = 0; r < rails; r++) {
        railsArr[r] = str.slice(pos, pos + railCounts[r]).split("");
        pos += railCounts[r];
    }
    let out = "";
    railsArr.map(()=>0);
    const index = Array(rails).fill(0);
    for (let r of pattern) out += railsArr[r][index[r]++];
    return out;
}

function polybiusEncode(str) {
    const a = "ABCDEFGHIKLMNOPQRSTUVWXYZ";
    let out = "";
    for (let c of str.toUpperCase()) {
        if (c === "J") c = "I";
        const idx = a.indexOf(c);
        if (idx === -1) out += c;
        else out += `${Math.floor(idx/5)+1}${(idx%5)+1}`;
    }
    return out;
}

function polybiusDecode(str) {
    const a = "ABCDEFGHIKLMNOPQRSTUVWXYZ";
    let out = "";
    for (let i = 0; i < str.length; i += 2) {
        const row = parseInt(str[i]);
        const col = parseInt(str[i+1]);
        if (isNaN(row) || isNaN(col)) return str;
        out += a[(row-1)*5 + (col-1)];
    }
    return out;
}



function decodeAscii85(str) {
    str = str.replace(/^<~/, "").replace(/~>$/, "").replace(/\s+/g, "");
    let output = [];

    for (let i = 0; i < str.length; i += 5) {
        let chunk = str.slice(i, i+5);
        let num = 0;

        for (let j = 0; j < chunk.length; j++) {
            num = num * 85 + (chunk.charCodeAt(j) - 33);
        }

        output.push(
            (num >> 24) & 0xFF,
            (num >> 16) & 0xFF,
            (num >> 8) & 0xFF,
            num & 0xFF
        );
    }
    return new TextDecoder().decode(new Uint8Array(output));
}

function encodeROT13(str) {
    return str.replace(/[A-Za-z]/g, c =>
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"[
            ("NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm".indexOf(c))
        ]
    );
}

function decodeROT13(str) {
    return encodeROT13(str);
}

function encodeURLBase64(str) {
    return encodeBase64Url(str);
}

function decodeURLBase64(str) {
    return decodeBase64Url(str);
}

function encodeUTF8Bytes(str) {
    return Array.from(new TextEncoder().encode(str)).join(' ');
}

function decodeUTF8Bytes(str) {
    return new TextDecoder().decode(
        new Uint8Array(str.split(' ').map(n => parseInt(n)))
    );
}

function encodeBinary16(str) {
    return Array.from(str).map(c =>
        c.charCodeAt(0).toString(2).padStart(16,'0')
    ).join(' ');
}

function decodeBinary16(str) {
    return str.split(' ').map(b =>
        String.fromCharCode(parseInt(b,2))
    ).join('');
}

const z85chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.-:+=^!/*?&<>()[]{}@%$#";
const z85map = Object.fromEntries([...z85chars].map((c,i)=>[c,i]));

function encodeZ85(str) {
    let bytes = [...new TextEncoder().encode(str)];
    while (bytes.length % 4 !== 0) bytes.push(0);

    let output = "";
    for (let i = 0; i < bytes.length; i += 4) {
        let value =
            bytes[i] * 256**3 +
            bytes[i+1] * 256**2 +
            bytes[i+2] * 256 +
            bytes[i+3];

        let block = "";
        for (let j = 0; j < 5; j++) {
            block = z85chars[value % 85] + block;
            value = Math.floor(value / 85);
        }
        output += block;
    }
    return output;
}

function decodeZ85(str) {
    let output = [];

    for (let i = 0; i < str.length; i += 5) {
        let value = 0;
        for (let j = 0; j < 5; j++) {
            value = value * 85 + z85map[str[i+j]];
        }

        output.push(
            (value >> 24) & 255,
            (value >> 16) & 255,
            (value >> 8) & 255,
            value & 255
        );
    }
    return new TextDecoder().decode(new Uint8Array(output));
}

function encodeBinHex(str) {
    return Array.from(str).map(c => c.charCodeAt(0).toString(16).padStart(2,'0')).join('');
}

function decodeBinHex(str) {
    try {
        return str.match(/.{1,2}/g).map(h => String.fromCharCode(parseInt(h,16))).join('');
    } catch {
        return "Invalid BinHex input";
    }
}

function encodeBase36(str) {
    let hex = Array.from(new TextEncoder().encode(str))
        .map(b=>b.toString(16).padStart(2,"0"))
        .join("");
    return BigInt("0x" + hex).toString(36);
}

function decodeBase36(str) {
    let hex = BigInt("0x" + BigInt("0").toString(16)).toString(16);
    hex = BigInt("0x" + BigInt(str, 36).toString(16)).toString(16);
    if (hex.length % 2) hex = "0" + hex;
    let bytes = new Uint8Array(hex.match(/.{2}/g).map(x=>parseInt(x,16)));
    return new TextDecoder().decode(bytes);
}

const base62chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

function encodeBase62(str) {
    let bytes = [...new TextEncoder().encode(str)];
    let num = BigInt("0x" + bytes.map(b=>b.toString(16).padStart(2,"0")).join(""));
    let out = "";
    while (num > 0n) {
        out = base62chars[Number(num % 62n)] + out;
        num /= 62n;
    }
    return out;
}

function decodeBase62(str) {
    let num = 0n;
    for (let c of str) num = num * 62n + BigInt(base62chars.indexOf(c));
    let hex = num.toString(16);
    if (hex.length % 2) hex = "0" + hex;
    let bytes = new Uint8Array(hex.match(/.{2}/g).map(h=>parseInt(h,16)));
    return new TextDecoder().decode(bytes);
}

function encodeBase64Url(str) {
    return btoa(unescape(encodeURIComponent(str)))
        .replace(/\+/g,"-")
        .replace(/\//g,"_")
        .replace(/=+$/,"");
}

function decodeBase64Url(str) {
    str = str.replace(/-/g,"+").replace(/_/g,"/");
    while (str.length % 4) str += "=";
    return decodeURIComponent(escape(atob(str)));
}

function encodeText() {
    lastAction = "encode";
    const input = inputText.value;
    if(!input) return resultDiv.innerText = "";

    switch(currentType){
        case "base64": try{resultDiv.innerText = btoa(unescape(encodeURIComponent(input)));} catch{resultDiv.innerText="Error encoding Base64";} break;
        case "hex": resultDiv.innerText = Array.from(input).map(c=>c.charCodeAt(0).toString(16).padStart(2,'0')).join(' '); break;
        case "url": resultDiv.innerText = encodeURIComponent(input); break;
        case "html": resultDiv.innerText = input.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); break;
        case "unicode": resultDiv.innerText = Array.from(input).map(c=>'\\u'+c.charCodeAt(0).toString(16).padStart(4,'0')).join(' '); break;
        case "ascii": resultDiv.innerText = Array.from(input).map(c=>c.charCodeAt(0)).join(' '); break;
        case "morse": resultDiv.innerText = Array.from(input.toUpperCase()).map(c=>morseMap[c]||'').join(' '); break;
        case "binary": resultDiv.innerText = Array.from(input).map(c=>c.charCodeAt(0).toString(2).padStart(8,'0')).join(' '); break;
        case "octal": resultDiv.innerText = Array.from(input).map(c=>c.charCodeAt(0).toString(8).padStart(3,'0')).join(' '); break;
        case "base32": resultDiv.innerText = encodeBase32(input); break;
        case "base58": resultDiv.innerText = encodeBase58(input); break;
        case "base64url": resultDiv.innerText = encodeBase64Url(input); break;
        case "ascii85": resultDiv.innerText = encodeAscii85(input); break;
        case "z85": resultDiv.innerText = encodeZ85(input); break;
        case "base36": resultDiv.innerText = encodeBase36(input); break;
        case "base62": resultDiv.innerText = encodeBase62(input); break;
        case "base58check": encodeBase58Check(input).then(res=>resultDiv.innerText=res); break;
        case "binhex": resultDiv.innerText = encodeBinHex(input); break;
        case "rot13": resultDiv.innerText = encodeROT13(input); break;
        case "urlbase64": resultDiv.innerText = encodeURLBase64(input); break;
        case "utf8": resultDiv.innerText = encodeUTF8Bytes(input); break;
        case "binary16": resultDiv.innerText = encodeBinary16(input); break;
        case "rot47": resultDiv.innerText = rot47(input); break;
        case "atbash": resultDiv.innerText = atbash(input); break;
        case "caesar": resultDiv.innerText = caesar(input, 3); break;
        case "uuencode": resultDiv.innerText = uuencode(input); break;
        case "xxencode": resultDiv.innerText = xxencode(input); break;
        case "rot5": resultDiv.innerText = rot5(input); break;
        case "rot18": resultDiv.innerText = rot18(input); break;
        case "substitution": resultDiv.innerText = substitution(input); break;
        case "baconian": resultDiv.innerText = baconianEncode(input); break;
        case "railfence": resultDiv.innerText = railFenceEncrypt(input); break;
        case "polybius": resultDiv.innerText = polybiusEncode(input); break;
        case "vigenere": {
            const key = prompt("Vigenère key (leave empty for default KEY):") || "KEY";
            resultDiv.innerText = vigenereEncrypt(input, key);
            break;
        }
        case "reverse": resultDiv.innerText = reverse(input); break;

    }
}

function decodeText() {
    lastAction = "decode";
    const input = inputText.value;
    if (!input) return resultDiv.innerText = "";

    try {
        switch(currentType) {
            case "base64": resultDiv.innerText = decodeURIComponent(escape(atob(input))); break;
            case "hex": resultDiv.innerText = input.split(' ').map(h=>String.fromCharCode(parseInt(h,16))).join(''); break;
            case "url": resultDiv.innerText = decodeURIComponent(input); break;
            case "html": const txt = document.createElement("textarea"); txt.innerHTML = input; resultDiv.innerText = txt.value; break;
            case "unicode": resultDiv.innerText = input.split(' ').map(u=>String.fromCharCode(parseInt(u.replace('\\u',''),16))).join(''); break;
            case "ascii": resultDiv.innerText = input.split(' ').map(n=>String.fromCharCode(parseInt(n))).join(''); break;
            case "morse": const revMorse = Object.fromEntries(Object.entries(morseMap).map(([k,v])=>[v,k])); resultDiv.innerText = input.split(' ').map(c=>revMorse[c]||'').join(''); break;
            case "binary": resultDiv.innerText = input.split(' ').map(b=>String.fromCharCode(parseInt(b,2))).join(''); break;
            case "octal": resultDiv.innerText = input.split(' ').map(o=>String.fromCharCode(parseInt(o,8))).join(''); break;
            case "ascii85": resultDiv.innerText = decodeAscii85(input); break;
            case "z85": resultDiv.innerText = decodeZ85(input); break;
            case "base36": resultDiv.innerText = decodeBase36(input); break;
            case "base62": resultDiv.innerText = decodeBase62(input); break;
            case "base58check": resultDiv.innerText = decodeBase58Check(input); break;
            case "binhex": resultDiv.innerText = decodeBinHex(input); break;
            case "rot13": resultDiv.innerText = decodeROT13(input); break;
            case "urlbase64": resultDiv.innerText = decodeURLBase64(input); break;
            case "utf8": resultDiv.innerText = decodeUTF8Bytes(input); break;
            case "binary16": resultDiv.innerText = decodeBinary16(input); break;
            case "rot47": resultDiv.innerText = rot47(input); break;
            case "atbash": resultDiv.innerText = atbash(input); break;
            case "caesar": resultDiv.innerText = caesar(input, 26 - 3); break;
            case "uuencode": resultDiv.innerText = uudecode(input); break;
            case "xxencode": resultDiv.innerText = xxdecode(input); break;
            case "rot5": resultDiv.innerText = rot5(input); break;
            case "rot18": resultDiv.innerText = rot18(input); break;
            case "substitution": resultDiv.innerText = substitution(input); break;
            case "baconian": resultDiv.innerText = baconianDecode(input); break;
            case "railfence": resultDiv.innerText = railFenceDecrypt(input); break;
            case "polybius": resultDiv.innerText = polybiusDecode(input); break;
            case "vigenere": {
                const key = prompt("Vigenère key for decryption (leave empty for default KEY):") || "KEY";
                resultDiv.innerText = vigenereDecrypt(input, key);
                break;
            }
            case "reverse": resultDiv.innerText = reverse(input); break;
            default: resultDiv.innerText = "Unknown decode type"; break;
        }
    } catch (e) {
        resultDiv.innerText = `Error decoding ${currentType}: ${e.message || e}`;
    }
}

function reverseText(){
    const temp=inputText.value;
    inputText.value=resultDiv.innerText;
    resultDiv.innerText=temp;
}

function copyResult(button){
    const text=resultDiv.innerText;
    if(!text) return;
    navigator.clipboard.writeText(text).then(()=>{button.classList.add("copied"); setTimeout(()=>button.classList.remove("copied"),280);});
}

inputText.addEventListener("input", () => {
    if(lastAction === "encode") encodeText();
    else if(lastAction === "decode") decodeText();
});

</script>

</body>
</html>

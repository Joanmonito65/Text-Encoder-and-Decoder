<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Text Encoder/Decoder</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');

body {
    margin: 0;
    padding: 0;
    font-family: 'Inter', sans-serif;
    background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    color: #fff;
}

.container {
    background-color: rgba(0,0,0,0.75);
    padding: 40px;
    border-radius: 20px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    max-width: 600px;
    width: 90%;
    text-align: center;
}

h1 {
    margin-bottom: 20px;
    font-weight: 600;
}

.tabs {
    display: flex;
    flex-wrap: nowrap;
    overflow-x: auto;
    gap: 5px;
    justify-content: flex-start;
    margin-bottom: 15px;
    scrollbar-width: none;
}

.tabs::-webkit-scrollbar {
    display: none;
}

.tab {
    padding: 8px 12px;
    border-radius: 10px 10px 0 0;
    background-color: #6c4dff;
    cursor: pointer;
    white-space: nowrap;
    flex-shrink: 0;
    transition: 0.3s;
}

.tab.active {
    background-color: #570ed4;
}

textarea {
    width: 100%;
    height: 120px;
    padding: 15px;
    border-radius: 10px;
    border: none;
    font-size: 16px;
    resize: none;
    margin-bottom: 20px;
}

#dropArea {
    margin-bottom: 15px;
    padding: 15px;
    border: 2px dashed rgba(255,255,255,0.5);
    border-radius: 10px;
    cursor: pointer;
}

#dropArea.dragover {
    background-color: rgba(255,255,255,0.1);
}

#resultContainer {
    margin-top: 20px;
    background-color: rgba(255,255,255,0.1);
    padding: 15px;
    border-radius: 10px;
    min-height: 50px;
    max-height: 200px;
    font-size: 15px;
    display: block;
    text-align: left;
    overflow-y: auto;
    word-break: break-all;
}

#resultContainer::-webkit-scrollbar {
    width: 8px;
}

#resultContainer::-webkit-scrollbar-track {
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
}

#resultContainer::-webkit-scrollbar-thumb {
    background: rgba(255,255,255,0.3);
    border-radius: 10px;
}

.button, .copy-btn, .reverse-btn {
    color: #fff;
    border: none;
    padding: 12px 25px;
    margin: 5px;
    font-size: 16px;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.button, .copy-btn {
    background-color: #6c4dff;
}

.button:hover, .copy-btn:hover {
    background-color: #570ed4;
    transform: translateY(-1px);
}

.reverse-btn {
    background-color: #ff9800;
}

.reverse-btn:hover {
    background-color: #f96540;
    transform: translateY(-1px);
}

@keyframes pop {
    0% { transform: scale(1); }
    50% { transform: scale(1.18); }
    100% { transform: scale(1); }
}

.button.copied, .copy-btn.copied {
    animation: pop 0.28s ease;
}
</style>
</head>
<body>

<div class="container">
    <h1>Text Encoder/Decoder</h1>

    <div class="tabs">
        <div class="tab active" data-type="base64">Base64</div>
        <div class="tab" data-type="hex">Hex</div>
        <div class="tab" data-type="url">URL</div>
        <div class="tab" data-type="html">HTML</div>
        <div class="tab" data-type="unicode">Unicode</div>
        <div class="tab" data-type="ascii">ASCII</div>
        <div class="tab" data-type="morse">Morse</div>
        <div class="tab" data-type="binary">Binary</div>
        <div class="tab" data-type="octal">Octal</div>
        <div class="tab" data-type="base32">Base32</div>
        <div class="tab" data-type="base58">Base58</div>
        <div class="tab" data-type="base64url">Base64Url</div>
        <div class="tab" data-type="ascii85">Ascii85</div>
        <div class="tab" data-type="z85">Z85</div>
        <div class="tab" data-type="base36">Base36</div>
        <div class="tab" data-type="base62">Base62</div>
        <div class="tab" data-type="base58check">Base58Check</div>
        <div class="tab" data-type="binhex">BinHex</div>

    </div>

    <textarea id="inputText" placeholder="Enter text here..."></textarea>

    <div id="dropArea">Drag & Drop a text file here or click to select</div>
    <input type="file" id="fileInput" style="display:none;">

    <button class="button" onclick="encodeText()">Encode</button>
    <button class="button" onclick="decodeText()">Decode</button>
    <button class="reverse-btn" onclick="reverseText()">Reverse</button>

    <div id="resultContainer">
        <div id="result"></div>
    </div>

    <button class="copy-btn" onclick="copyResult(this)">Copy</button>
</div>

<script>
const inputText = document.getElementById("inputText");
const resultDiv = document.getElementById("result");
const dropArea = document.getElementById("dropArea");
const fileInput = document.getElementById("fileInput");
let lastAction = null;
let currentType = "base64";

document.querySelectorAll(".tab").forEach(tab => {
    tab.addEventListener("click", () => {
        document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
        tab.classList.add("active");
        currentType = tab.dataset.type;
        resultDiv.innerText = "";
    });
});

dropArea.addEventListener("dragover", (e) => {
    e.preventDefault();
    dropArea.classList.add("dragover");
});

dropArea.addEventListener("dragleave", () => {
    dropArea.classList.remove("dragover");
});

dropArea.addEventListener("drop", (e) => {
    e.preventDefault();
    dropArea.classList.remove("dragover");
    if(e.dataTransfer.files[0]) readFile(e.dataTransfer.files[0]);
});

dropArea.addEventListener("click", () => fileInput.click());
fileInput.addEventListener("change", () => {
    if(fileInput.files[0]) readFile(fileInput.files[0]);
});

function readFile(file) {
    if(!file.type.startsWith("text/")) {
        resultDiv.innerText = "Error: Only text files are allowed";
        return;
    }
    const reader = new FileReader();
    reader.onload = () => {
        inputText.value = reader.result;
        fileInput.value = "";
    };
    reader.readAsText(file);
}

const morseMap = {
    'A':'.-','B':'-...','C':'-.-.','D':'-..','E':'.','F':'..-.','G':'--.',
    'H':'....','I':'..','J':'.---','K':'-.-','L':'.-..','M':'--','N':'-.',
    'O':'---','P':'.--.','Q':'--.-','R':'.-.','S':'...','T':'-','U':'..-',
    'V':'...-','W':'.--','X':'-..-','Y':'-.--','Z':'--..',
    '0':'-----','1':'.----','2':'..---','3':'...--','4':'....-','5':'.....',
    '6':'-....','7':'--...','8':'---..','9':'----.',' ':'/','!':'-.-.--',
    '?':'..--..', '.':'.-.-.-', ',':'--..--', ':':'---...'
};

const base32chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";

function encodeBase32(str) {
    const bytes = new TextEncoder().encode(str);
    let bits = "";
    for (let b of bytes) bits += b.toString(2).padStart(8,"0");
    let output = "";
    for (let i = 0; i < bits.length; i += 5) {
        const chunk = bits.substring(i, i+5);
        output += base32chars[parseInt(chunk.padEnd(5,"0"),2)];
    }
    while (output.length % 8 !== 0) output += "=";
    return output;
}

function decodeBase32(str) {
    str = str.replace(/=/g,"");
    let bits = "";
    for (let c of str) bits += base32chars.indexOf(c).toString(2).padStart(5,"0");
    let bytes = [];
    for (let i = 0; i < bits.length; i += 8) {
        const byte = bits.substring(i, i+8);
        if (byte.length === 8) bytes.push(parseInt(byte,2));
    }
    return new TextDecoder().decode(new Uint8Array(bytes));
}

const base58charsCheck = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

function encodeBase58Check(str) {
    const crypto = window.crypto || window.msCrypto;
    let bytes = Array.from(new TextEncoder().encode(str));
    const hashBuffer = crypto.subtle.digest ? crypto.subtle.digest("SHA-256", new Uint8Array(bytes)) : null;
    if (!hashBuffer) return encodeBase58(str);
    return hashBuffer.then(hash => {
        const hashBytes = new Uint8Array(hash);
        const checksum = hashBytes.slice(0, 4);
        bytes = bytes.concat(Array.from(checksum));
        let num = BigInt("0x" + bytes.map(b => b.toString(16).padStart(2, "0")).join(""));
        let output = "";
        while (num > 0n) {
            const mod = num % 58n;
            num = num / 58n;
            output = base58charsCheck[Number(mod)] + output;
        }
        return output;
    });
}

function decodeBase58Check(str) {
    let num = 0n;
    for (let c of str) num = num * 58n + BigInt(base58charsCheck.indexOf(c));
    let hex = num.toString(16);
    if (hex.length % 2) hex = "0" + hex;
    let bytes = new Uint8Array(hex.match(/.{2}/g).map(h => parseInt(h,16)));
    bytes = bytes.slice(0, -4);
    return new TextDecoder().decode(bytes);
}

const base58chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

function encodeBase58(str) {
    let bytes = Array.from(new TextEncoder().encode(str));
    let num = BigInt("0x" + bytes.map(b => b.toString(16).padStart(2,"0")).join(""));
    let output = "";
    while (num > 0n) {
        const mod = num % 58n;
        num = num / 58n;
        output = base58chars[Number(mod)] + output;
    }
    return output;
}

function decodeBase58(str) {
    let num = 0n;
    for (let c of str) num = num * 58n + BigInt(base58chars.indexOf(c));
    let hex = num.toString(16);
    if (hex.length % 2) hex = "0" + hex;
    let bytes = new Uint8Array(hex.match(/.{2}/g).map(h => parseInt(h,16)));
    return new TextDecoder().decode(bytes);
}

function encodeAscii85(input) {
    let data = new TextEncoder().encode(input);
    let output = "<~";
    for (let i = 0; i < data.length; i += 4) {
        let chunk = data.slice(i, i+4);
        while (chunk.length < 4) chunk = new Uint8Array([...chunk, 0]);
        let num = (chunk[0]<<24) + (chunk[1]<<16) + (chunk[2]<<8) + chunk[3];

        if (num === 0) {
            output += "z";
        } else {
            let block = "";
            for (let j = 0; j < 5; j++) {
                block = String.fromCharCode((num % 85) + 33) + block;
                num = Math.floor(num / 85);
            }
            output += block;
        }
    }
    return output + "~>";
}

function decodeAscii85(str) {
    str = str.replace(/^<~/, "").replace(/~>$/, "").replace(/\s+/g, "");
    let output = [];

    for (let i = 0; i < str.length; i += 5) {
        let chunk = str.slice(i, i+5);
        let num = 0;

        for (let j = 0; j < chunk.length; j++) {
            num = num * 85 + (chunk.charCodeAt(j) - 33);
        }

        output.push(
            (num >> 24) & 0xFF,
            (num >> 16) & 0xFF,
            (num >> 8) & 0xFF,
            num & 0xFF
        );
    }
    return new TextDecoder().decode(new Uint8Array(output));
}

const z85chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.-:+=^!/*?&<>()[]{}@%$#";
const z85map = Object.fromEntries([...z85chars].map((c,i)=>[c,i]));

function encodeZ85(str) {
    let bytes = [...new TextEncoder().encode(str)];
    while (bytes.length % 4 !== 0) bytes.push(0);

    let output = "";
    for (let i = 0; i < bytes.length; i += 4) {
        let value =
            bytes[i] * 256**3 +
            bytes[i+1] * 256**2 +
            bytes[i+2] * 256 +
            bytes[i+3];

        let block = "";
        for (let j = 0; j < 5; j++) {
            block = z85chars[value % 85] + block;
            value = Math.floor(value / 85);
        }
        output += block;
    }
    return output;
}

function decodeZ85(str) {
    let output = [];

    for (let i = 0; i < str.length; i += 5) {
        let value = 0;
        for (let j = 0; j < 5; j++) {
            value = value * 85 + z85map[str[i+j]];
        }

        output.push(
            (value >> 24) & 255,
            (value >> 16) & 255,
            (value >> 8) & 255,
            value & 255
        );
    }
    return new TextDecoder().decode(new Uint8Array(output));
}

function encodeBinHex(str) {
    return Array.from(str).map(c => c.charCodeAt(0).toString(16).padStart(2,'0')).join('');
}

function decodeBinHex(str) {
    try {
        return str.match(/.{1,2}/g).map(h => String.fromCharCode(parseInt(h,16))).join('');
    } catch {
        return "Invalid BinHex input";
    }
}

function encodeBase36(str) {
    let hex = Array.from(new TextEncoder().encode(str))
        .map(b=>b.toString(16).padStart(2,"0"))
        .join("");
    return BigInt("0x" + hex).toString(36);
}

function decodeBase36(str) {
    let hex = BigInt("0x" + BigInt("0").toString(16)).toString(16);
    hex = BigInt("0x" + BigInt(str, 36).toString(16)).toString(16);
    if (hex.length % 2) hex = "0" + hex;
    let bytes = new Uint8Array(hex.match(/.{2}/g).map(x=>parseInt(x,16)));
    return new TextDecoder().decode(bytes);
}

const base62chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

function encodeBase62(str) {
    let bytes = [...new TextEncoder().encode(str)];
    let num = BigInt("0x" + bytes.map(b=>b.toString(16).padStart(2,"0")).join(""));
    let out = "";
    while (num > 0n) {
        out = base62chars[Number(num % 62n)] + out;
        num /= 62n;
    }
    return out;
}

function decodeBase62(str) {
    let num = 0n;
    for (let c of str) num = num * 62n + BigInt(base62chars.indexOf(c));
    let hex = num.toString(16);
    if (hex.length % 2) hex = "0" + hex;
    let bytes = new Uint8Array(hex.match(/.{2}/g).map(h=>parseInt(h,16)));
    return new TextDecoder().decode(bytes);
}

function encodeBase64Url(str) {
    return btoa(unescape(encodeURIComponent(str)))
        .replace(/\+/g,"-")
        .replace(/\//g,"_")
        .replace(/=+$/,"");
}

function decodeBase64Url(str) {
    str = str.replace(/-/g,"+").replace(/_/g,"/");
    while (str.length % 4) str += "=";
    return decodeURIComponent(escape(atob(str)));
}

function encodeText() {
    lastAction = "encode";
    const input = inputText.value;
    if(!input) return resultDiv.innerText = "";

    switch(currentType){
        case "base64": try{resultDiv.innerText = btoa(unescape(encodeURIComponent(input)));} catch{resultDiv.innerText="Error encoding Base64";} break;
        case "hex": resultDiv.innerText = Array.from(input).map(c=>c.charCodeAt(0).toString(16).padStart(2,'0')).join(' '); break;
        case "url": resultDiv.innerText = encodeURIComponent(input); break;
        case "html": resultDiv.innerText = input.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); break;
        case "unicode": resultDiv.innerText = Array.from(input).map(c=>'\\u'+c.charCodeAt(0).toString(16).padStart(4,'0')).join(' '); break;
        case "ascii": resultDiv.innerText = Array.from(input).map(c=>c.charCodeAt(0)).join(' '); break;
        case "morse": resultDiv.innerText = Array.from(input.toUpperCase()).map(c=>morseMap[c]||'').join(' '); break;
        case "binary": resultDiv.innerText = Array.from(input).map(c=>c.charCodeAt(0).toString(2).padStart(8,'0')).join(' '); break;
        case "octal": resultDiv.innerText = Array.from(input).map(c=>c.charCodeAt(0).toString(8).padStart(3,'0')).join(' '); break;
        case "base32": resultDiv.innerText = encodeBase32(input); break;
        case "base58": resultDiv.innerText = encodeBase58(input); break;
        case "base64url": resultDiv.innerText = encodeBase64Url(input); break;
        case "ascii85": resultDiv.innerText = encodeAscii85(input); break;
        case "z85": resultDiv.innerText = encodeZ85(input); break;
        case "base36": resultDiv.innerText = encodeBase36(input); break;
        case "base62": resultDiv.innerText = encodeBase62(input); break;
        case "base58check": encodeBase58Check(input).then(res=>resultDiv.innerText=res); break;
        case "binhex": resultDiv.innerText = encodeBinHex(input); break;

    }
}

function decodeText() {
    lastAction = "decode";
    const input = inputText.value;
    if(!input) return resultDiv.innerText = "";

    switch(currentType){
        case "base64": try{resultDiv.innerText = decodeURIComponent(escape(atob(input)));} catch{resultDiv.innerText="Error decoding Base64";} break;
        case "hex": try{resultDiv.innerText = input.split(' ').map(h=>String.fromCharCode(parseInt(h,16))).join('');} catch{resultDiv.innerText="Invalid Hex input";} break;
        case "url": try{resultDiv.innerText = decodeURIComponent(input);} catch{resultDiv.innerText="Invalid URL input";} break;
        case "html": const txt=document.createElement("textarea"); txt.innerHTML=input; resultDiv.innerText=txt.value; break;
        case "unicode": try{resultDiv.innerText = input.split(' ').map(u=>String.fromCharCode(parseInt(u.replace('\\u',''),16))).join('');} catch{resultDiv.innerText="Invalid Unicode input";} break;
        case "ascii": try{resultDiv.innerText = input.split(' ').map(n=>String.fromCharCode(parseInt(n))).join('');} catch{resultDiv.innerText="Invalid ASCII input";} break;
        case "morse": try{const revMorse=Object.fromEntries(Object.entries(morseMap).map(([k,v])=>[v,k])); resultDiv.innerText=input.split(' ').map(c=>revMorse[c]||'').join('');} catch{resultDiv.innerText="Invalid Morse input";} break;
        case "binary": try{resultDiv.innerText = input.split(' ').map(b=>String.fromCharCode(parseInt(b,2))).join('');} catch{resultDiv.innerText="Invalid Binary input";} break;
        case "octal": try{resultDiv.innerText = input.split(' ').map(o=>String.fromCharCode(parseInt(o,8))).join('');} catch{resultDiv.innerText="Invalid Octal input";} break;
        case "ascii85": resultDiv.innerText = decodeAscii85(input); break;
        case "z85": resultDiv.innerText = decodeZ85(input); break;
        case "base36": resultDiv.innerText = decodeBase36(input); break;
        case "base62": resultDiv.innerText = decodeBase62(input); break;
        case "base58check": resultDiv.innerText = decodeBase58Check(input); break;
        case "binhex": resultDiv.innerText = decodeBinHex(input); break;

    }
}

function reverseText(){
    const temp=inputText.value;
    inputText.value=resultDiv.innerText;
    resultDiv.innerText=temp;
}

function copyResult(button){
    const text=resultDiv.innerText;
    if(!text) return;
    navigator.clipboard.writeText(text).then(()=>{button.classList.add("copied"); setTimeout(()=>button.classList.remove("copied"),280);});
}

inputText.addEventListener("input", () => {
    if(lastAction === "encode") encodeText();
    else if(lastAction === "decode") decodeText();
});

</script>

</body>
</html>
